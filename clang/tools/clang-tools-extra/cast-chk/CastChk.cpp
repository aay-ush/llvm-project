// Declares clang::SyntaxOnlyAction
#include "clang/Frontend/FrontendActions.h"
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"

// Declares llvm::cl::extrahelp
#include "llvm/Support/CommandLine.h"

// AST Matchers
#include "clang/ASTMatchers/ASTMatchFinder.h"
#include "clang/ASTMatchers/ASTMatchers.h"

// Source locating
#include "clang/StaticAnalyzer/Core/BugReporter/BugReporter.h"
#include "clang/Analysis/AnalysisDeclContext.h"

#include "clang/AST/Type.h"
#include "clang/AST/Expr.h"
#include "clang/AST/Decl.h"
#include "clang/AST/Stmt.h"

#include "clang/AST/ODRHash.h"
#include "llvm/ADT/ArrayRef.h"

#include <iostream>
#include <fstream>
#include <sstream>

#include "llvm/Support/raw_os_ostream.h"
//#include "llvm/Support/raw_ostream.h"
#include <string>
#include <unordered_map>
#include <utility>
#include <algorithm>
#include <optional>

#include "utils.h"

using namespace clang::tooling;
using namespace llvm;

using namespace clang;
using namespace clang::ast_matchers;
using namespace clang::ento;

// TODO: use TypeInfo from context to detect incompatible size casts.

//StatementMatcher CastMatcher = castExpr(hasCastKind(CK_BitCast)).bind("cast");


// TODO TODO:
// &i -> trace to int i;

// TODO TODO
//  _ Arg matching:
//    * Match arg with parm.
//    * Tag arg as arg with arg number in call. (cast source)
//  _ Parm matching:
//    * Get containing function decl.
//    * Tag parm as parm with parm number. (cast source)
//
//  _ Composable function tag from all the params.

using CastOperand = clang::Decl;
using CastPair = std::pair<CastOperand const*, CastOperand const*>;

// Generated by looking at cast `expr`.
struct CastData{
    std::string fromId;  // From identifier
    std::string from;    // typeof(fromID)
    std::string toId;    // to identifier
    std::string to;      // typeof(toID)
    //std::list<std::pair<CastPair, CastData> castChain; // links to related casts
    std::list<CastData> castChain; // links to related casts
    // meta
    std::string fromCategory;        // Ptr or array
    std::string toCategory;          // Ptr or array
    std::string expr;                // cast expression
    std::string exprType;            // type of cast expression
    std::string containingFunction;  // Function where cast expression appears
    // Should it be linked decl? Doesn't have it to be. Links are maintained through map.
    // It is technically the callee function, but for non-call functions it will be null or same function (cast can be linked to assignments within same function).
    std::optional<std::string> linkedFunction;      // For function calls, this is the callee.
    std::string sourceLine;          // Location info from source manager.
    // Check if needed. Maybe not.
    //unsigned pos;                    // position of arg/param
    //bool isArg = false;              // arg or param?

    /*
    operator std::string() const {
        return "[" + from + " -> " + to + "]";
    }
    */
};

std::ostream& operator<<(std::ostream &os, std::list<CastData> const & list);
std::ostream& operator<<(std::ostream &os, CastData const & info);
std::ostream& dumpcsv(std::ostream &os, CastData const & info);
std::ostream& dumpcsvChain(std::ostream &os, std::list<CastData> const & list);

std::ostream& dumpcsvChain(std::ostream &os, std::list<CastData> const & list) {
    for(auto const& i: list) {
        dumpcsv(os, i);
    }
    return os;
}

std::ostream& dumpcsv(std::ostream &os, CastData const & info) {
    os << "{'sourceCategory': '" << info.fromCategory << "', 's_identifier': '" << info.fromId << "', 's_type': '" << info.from
        << "', 'toCategory': '" << info.toCategory << "', 't_identifier': '" << info.toId << "', 't_type': '" << info.to
        << "', 'castExpression': '[" << info.expr << "]', 'chainLength': '" << info.castChain.size()
        << "', 'containerFunction': '" << info.containingFunction << "', 'linkedFunction: '" << info.linkedFunction.value_or("(none)")
        << "', 'location': '" << info.sourceLine
        << "', 'chain': '";
    dumpcsvChain(os, info.castChain) << "',\n},\n";

    return os;
}

std::ostream& operator<<(std::ostream &os, std::list<CastData> const & list) {
    //os << "  ---start of chain---\n";
    for(auto const& i: list) {
        os << i;
        //dumpcsv(os, i);
    }
    //os << "  ---end of chain---\n";
    return os;
}

std::ostream& operator<<(std::ostream &os, CastData const & info) {
    os << "  Casting from: [" << info.fromCategory << "] " << info.fromId << " <" << info.from << ">\n"
       << "            to: [" << info.toCategory << "] " << info.toId << " <" << info.to << ">\n"
       << "          with: [" << info.exprType << "] " << info.expr << "\n"
       << "            at: "  << info.sourceLine << "\n"
       << "            in: function (" << info.containingFunction << ")" << "\n"
       << "   Linked func: " << info.linkedFunction.value_or("(none)") << "\n"
       << " --Link-->\n  " << info.castChain;

    return os;
}

/*
int f(void *pv){
    void* pv1 = pv;
    void* pv2 = pv;
    void* pv3 = pv2;

    int* pi = pv3;
    return *pi;
}
*/

// TODO TODO
//  * Replace pair of clang nodes with declaration strings.
//    There's no point in keeping pointers anyway. Since links may have different node type as parents.
//  ? It's more robust to use string to match decls and exprs.

template<>
struct std::hash<CastPair>
{
    unsigned operator()(CastPair const& p) const noexcept {
        /*
        std::size_t h1 = std::hash<CastOperand const*>{}(p.first);
        std::size_t h2 = std::hash<CastOperand const*>{}(p.second);
        return h1 ^ (h2 << 1);
        */
        ODRHash hasher;
        //hasher.AddStmt(p.first);
        //hasher.AddStmt(p.second);
        if(p.first)
            hasher.AddDecl(p.first);
        if(p.second)
            hasher.AddDecl(p.second);
        return hasher.CalculateHash();
    }
};


// Census adds cast history to a `decl`.
using Census = std::unordered_map<CastPair, CastData>;
Census census;

/*
ostream& operator<<(ostream& os, Census const casts) {
    for(auto const& [cast, data]: casts) {
        os << cast << "\n    " << data << "\n";
    }
}
ostream& operator<<(ostream& os, CastPair const& cast) {
    os << "[" + cast.first
}
*/


// TODO TODO
//  * Add function name in cast site.
//  - Add match for parameters so their casts can be tagged.
//  * Add info on cast operation (assignment, parameter passing, etc.)
//  - Create history tag for cast and function.
//  - Add missing cast dumps. For example in other cast types.(?).
StatementMatcher CastMatcher = castExpr(
                                allOf(
                                    hasCastKind(CK_BitCast),
                                    anyOf( // technically just any of expr or decl is needed.
                                        //hasAncestor(varDecl().bind("var")),
                                        hasAncestor(declStmt().bind("var")),
                                        hasAncestor(binaryOperator().bind("binop")),
                                        hasAncestor(callExpr().bind("call")),
                                        hasAncestor(expr().bind("gexpr"))),
                                    hasDescendant(declRefExpr().bind("castee")))
                                ).bind("cast");


// Apply a custom category to all cli options so that they are the only ones displayed
static llvm::cl::OptionCategory MyToolCategory("my-tool options");

// CommonOptionsParser declares HelpMessage with a description of the common cli options
// related to the compilation db and input files. (Nice to have help)
static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);

// Help message for this specific tool.
static cl::extrahelp Morehelp("\nMore help text...\n");

//std::ofstream FOUT;


class CastMatchCallback: public MatchFinder::MatchCallback {

public:
    void run(MatchFinder::MatchResult const &result) override {
        assert(result);
        auto *context = result.Context;
        assert(context);
        auto policy = context->getLangOpts();

        // Cast expression
        auto const *castExpr = result.Nodes.getNodeAs<clang::CastExpr>("cast");
        assert(castExpr);
        auto const *fn = getContainerFunctionDecl(context, castExpr);
        assert(fn);
        auto const &containerFn = getContainerFunction(context, castExpr);
        std::optional<std::string> callee;


        // Source operand (i.e. the expression which is being cast)
        //auto const *castSource = castExpr->getSubExprAsWritten();
        auto const *castSource = result.Nodes.getNodeAs<clang::DeclRefExpr>("castee");
        assert(castSource);

        // Retrieve container function for source cast expr.
        /*
        auto const *decl = castSource->getDecl();
        auto const *declContext = decl->getParentFunctionOrMethod();
        auto const *parentContext = declContext->getParentASTContext();
        auto const * //...
        */

        std::string dest;
        auto const *var = result.Nodes.getNodeAs<clang::DeclStmt>("var");
        auto const *gexpr = result.Nodes.getNodeAs<clang::Expr>("gexpr");
        auto const *binop = result.Nodes.getNodeAs<clang::BinaryOperator>("binop");
        auto const *call = result.Nodes.getNodeAs<clang::CallExpr>("call");

        std::string castExprType;
        CastPair cast;
        cast.first = castSource->getDecl();
        auto src = toString(context, castSource);

        if(auto srcParmMatch = getParameterMatch(fn, castSource->getNameInfo())) {
            auto pos = *srcParmMatch;
            //FOUT << "[DEBUG](CastChk.cpp)" << "parmPos: " << pos << "\n";
            src = src + " " + toString(context, fn, pos);
        }
        else {
            // TODO: Reach decl. Assign chain?
            src = src + " (Could not match with fn parameter)";
        }
        
        if(!!var) {
            cast.second = var->getSingleDecl(); // TODO Examples where decls() or DeclGroup() may be required.
            //

            //
            castExprType = "assignment";
            dest = toString(context, var);
            callee = containerFn;

            // Check if operands //esp. RHS match(es) params
            //  - Check if operands are linked to function params

        /*
        } else if(!!binop) {
            callee = containerFn;
            cast.second = binop;
            castExprType = "binop";
            dest = toString(context, binop);
        */

        } else if(!!call) {
            // Call type: clang::CallExpr
            // TODO Change to call.param decl
            // cast.second = call;
            castExprType = "call";

            // Get cast expressions position in call argument list.
            unsigned argPos = 0;
            std::find_if(call->arg_begin(), call->arg_end(),
                    [&] (auto const & arg) {
                        argPos++;
                        return clang::Expr::isSameComparisonOperand(arg, castExpr);
                    });

            if (argPos > call->getNumArgs()) {
                dest = "Invalid arg found";
            }
            else {
                cast.second = getParamDecl(context, call, argPos-1);
                dest = toString(context, call, argPos-1);
            }
            // parm->getOriginalType : QualType
            // parm->getFunctionScopeIndex: unsigned parameter index

            // Get function body and trigger match on function casts.
            auto const * calledFn = call->getDirectCallee();
            assert(calledFn);
            callee = calledFn->getNameAsString();

            // Trigger cast check for the called function.
            if(calledFn->hasBody()) {
                auto const *body = calledFn->getBody();
                assert(body);
                MatchFinder m;
                m.match(*body, *context);
            }
        }
        /*
        } else if(!!gexpr) {
            cast.second = gexpr;
            castExprType = "gexpr";
            dest = toString(context, gexpr);
        }
        */

        /*
        // Dump ast
        FOUT << "------- AST DUMP----\n";
        std::string dmpstr;
        llvm::raw_string_ostream dmpstrm(dmpstr);
        castExpr->dump(dmpstrm, *context);
        FOUT << dmpstr << "\n";
        FOUT << "----end AST DUMP----\n";

        auto parents = context->getParents(*castExpr);
        FOUT << "---    Parent Dumps---";
        for(auto const& parent: parents) {
            std::string dumpstr;
            llvm::raw_string_ostream dumpstrm(dumpstr);
            parent.dump(dumpstrm, *context);
            FOUT << dumpstr << "\n";
            auto const * fn = parent.get<clang::FunctionDecl>();
        }
        FOUT << "---end Parent Dumps---";
        */

        CastData info{//toString(context, castSource),                
                      src,                                          // source id
                      typeof(context, castSource),                  // source (decl) type
                      dest,                                         // dest id
                      typeof(context, castExpr),                    // destination type
                      {},                                           // Start with empty chain
                      getTypeCategoryName(context, castSource),     // src type class
                      getTypeCategoryName(context, castExpr),       // dest type class
                      toString(context, castExpr),                  // cast expression
                      castExprType,                                 // expresion type
                      containerFn,                                  // containing function
                      callee,                                       // optional callee function
                      castExpr->getExprLoc().printToString(*result.SourceManager)
        };
        /*
        CastData info{toString(context, castExpr),                // source expr
                      typeof(context, castExpr),                  // source (decl) type
                      dest,                                         // dest expr
                      typeof(context, castExpr),                    // destination type
                      getTypeCategoryName(context, castSource),     // src type class
                      getTypeCategoryName(context, castExpr),       // dest type class
                      toString(context, castSource),                  // cast expression
                      castExprType};
        */
        
        // TODO TODO Find existing cast where cast.second is cast.first
        //  For every node in census (unord_map),
        //   - if key.second = source  => Match
        //   - if key.first = source   => List++
        //   - if key.second = target  => x
        //   - if key.first = target   => List++?
        // Build the cast chain using census map.
        std::list<CastData> chain;
        auto isLinkedToCast = [&](auto const& castpair, auto const& castinfo, auto const& match) -> auto {
            if (!castpair.second || !match)
                return false;
            return (castpair.second->getID() == match->getID());
        };

        /*
        using namespace std::placeholders;
        std::function<decltype(isLinkedToCast)> castLinker = std::bind(&decltype(isLinkedToCast)::operator(),
                                                                &isLinkedToCast,
                                                                _1, _2,
                                                                cast.first);
        */

        auto parentLink = std::find_if(census.begin(), census.end(),
                                [&](auto const& node) {
                                    return isLinkedToCast(node.first, node.second, cast.first);
                                });
        if (parentLink != census.end()) {
            auto& [_, parentData] = *parentLink;
            //chain.push_back(parentLink->second);
            parentData.castChain.push_back(info);
        }

        // Always insert so that further casts are easy to link.
        census.insert({cast, info});

        /* Dumps the whole AST!
        std::cout << "TUD:\n";
        auto *tud = context->getTranslationUnitDecl();
        tud->dumpAsDecl();
        */

        if(!FOUT.is_open()) {
            std::cout << "File open error.\n";
            return;
        }

        FOUT << "Cast site: " << info.sourceLine << "\n"
             << "    Casting: " << toString(context, castSource) << " -> " << dest << "\n"
             << "       from: [" << info.fromCategory << "] " << info.from << "\n"
             << "         to: [" << info.toCategory << "] " << info.to << "\n"
             << "       expr: " << "[" << info.exprType << "] " << info.expr << "\n"
             << "\n";


        FOUT << "# Census collection so far:\n";
        for(auto const& [cast, data]: census) {
           
            /*
            FOUT //<< "Cast expression: <" << toString(context, cast.first)
                 //<< " | " << toString(context, cast.second) << ">\n"
                 << "Data:\n" << data << "\n";
            */ 
            dumpcsv(FOUT, data);
        }
        FOUT << "# Census end.\n";

        // TODO: Emit error when a cast destination is incompatible with source/parent types.
    }
};


// Matcher code end
//-----------------------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////////////////
// Build:
//  cd <llvm dir>/build
//  ninja cast-chk
//
// Steps to execute:
//  bin/cast-chk <path/to>/qsort.c
//
//  (dump will be created in <exe dir>/census-dump.txt)
//-----------------------------------------------------------------------------------------

int main(int argc, const char **argv) {
    auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);
    if(!ExpectedParser) {
        llvm::errs() << ExpectedParser.takeError();
        return 1;
    }

    CommonOptionsParser& OptionsParser = ExpectedParser.get();
    ClangTool Tool(OptionsParser.getCompilations(),
                   OptionsParser.getSourcePathList());

    CastMatchCallback dumper;
    MatchFinder Finder;
    Finder.addMatcher(CastMatcher, &dumper);

    FOUT.open("census-dump.txt", std::ios::out);
    //return Tool.run(newFrontendActionFactory<clang::SyntaxOnlyAction>().get());
    return Tool.run(newFrontendActionFactory(&Finder).get());
}

